Nilable	nimonad/optional.html#Nilable	optional: Nilable	
UnboxError	nimonad/optional.html#UnboxError	optional: UnboxError	
Optional	nimonad/optional.html#Optional	optional: Optional	
boxedType	nimonad/optional.html#boxedType.t,typedesc[Optional[T]]	optional: boxedType[T](X: typedesc[Optional[T]]): typedesc[T]	
boxedType	nimonad/optional.html#boxedType.t,Optional[T]	optional: boxedType[T](self: Optional[T]): typedesc[T]	
none	nimonad/optional.html#none,typedesc[Nilable]	optional: none(T: typedesc[Nilable]): Optional[T]	
none	nimonad/optional.html#none,typedesc[]	optional: none(T: typedesc[not Nilable]): Optional[T]	
none	nimonad/optional.html#none,Unit	optional: none[T](_: Unit): Optional[T]	
none	nimonad/optional.html#none	optional: none[T](): Optional[T]	
some	nimonad/optional.html#some,T	optional: some[T: Nilable](value: T): Optional[T]	
some	nimonad/optional.html#some,T_2	optional: some[T: not Nilable](value: T): Optional[T]	
optional	nimonad/optional.html#optional,T	optional: optional[T: Nilable](value: T): Optional[T]	
isNone	nimonad/optional.html#isNone,Optional[T: Nilable]	optional: isNone[T: Nilable](self: Optional[T]): bool	
isNone	nimonad/optional.html#isNone,Optional[T: not Nilable]	optional: isNone[T: not Nilable](self: Optional[T]): bool	
isSome	nimonad/optional.html#isSome,Optional[T]	optional: isSome[T](self: Optional[T]): bool	
fold	nimonad/optional.html#fold,Optional[A],,	optional: fold[A; B](self: Optional[A]; then: A -&gt; B; else: Unit -&gt; B): B	
ifNone	nimonad/optional.html#ifNone,Optional[A],,	optional: ifNone[A; B](self: Optional[A]; then: () -&gt; B; else: A -&gt; B): B	
ifSome	nimonad/optional.html#ifSome,Optional[A],,	optional: ifSome[A; B](self: Optional[A]; then: A -&gt; B; else: () -&gt; B): B	
map	nimonad/optional.html#map,Optional[A],	optional: map[A; B](self: Optional[A]; f: A -&gt; B): Optional[B]	
join	nimonad/optional.html#join,Optional[Optional[T]]	optional: join[T](self: Optional[Optional[T]]): Optional[T]	
flatten	nimonad/optional.html#flatten,Optional[Optional[T]]	optional: flatten[T](self: Optional[Optional[T]]): Optional[T]	
flatMap	nimonad/optional.html#flatMap,Optional[A],	optional: flatMap[A; B](self: Optional[A]; f: A -&gt; Optional[B]): Optional[B]	
unboxOr	nimonad/optional.html#unboxOr,Optional[T],	optional: unboxOr[T](self: Optional[T]; else: Unit -&gt; T): T	
unboxOr	nimonad/optional.html#unboxOr,Optional[T],_2	optional: unboxOr[T](self: Optional[T]; else: () -&gt; T): T	
unbox	nimonad/optional.html#unbox,Optional[T]	optional: unbox[T](self: Optional[T]): T	
filter	nimonad/optional.html#filter,Optional[T],Predicate[T]	optional: filter[T](self: Optional[T]; predicate: Predicate[T]): Optional[T]	
`==`	nimonad/optional.html#==,Optional[T],Optional[T]	optional: `==`[T](self, other: Optional[T]): bool	
`$`	nimonad/optional.html#$,Optional[T]	optional: `$`[T](self: Optional[T]): string	
